# Вопросы:

## правильное использование БЭМ-сущностей

_Q_ какие части макета являются одним и тем же блоком?

1. Выделим отдельно слой каркаса:

- `layout` как общую "обвязку" по вертикальной оси
- `grid` как сетку для блоков

2. Выделим слой "паттернов" (очень понравилось, в свое время, такое смысловое
   определение из whitepaper tools)

- `hedaer` для четкой возможной структуры шапки (в данном случае простое
  деление на левую и правые части `header__title` + `header__controls`)
- `footer` аналогично `header`
- `form` как заданную структуру формы из 3-х частей `form__title`,
  `form__items`, `form__controls`
- `icon-content` как заданную структуру иконки + содержимого. В идеальном
  варианте иконка умеет быть слева, справа, с обеих сторон, сверху, снизу.
  Чем умеет быть содержимое будем ограничивать от задач. Теоретически
  ограничений нет. Даже start-screen можно организовать через этот паттерн. В
  текущей реализации: только мета-информация реализованная через
  `icon-content`, но хочетя попробовать и содержимое кнопки и `start-screen`
  сделать через этот же паттерн.
- `card` как основной элемент группировки контента. Точнее так хотелось бы, но,
  как будто, реализацию карточки коммита лучше сделать отдельной сущностью,
  слишком она отличается от обычной "карточки". Или больше
  модификаторов, богу модификаторов )
- `button` как каркасное решение возможности кнопки быть икнока + текст /
  текст / иконка / текст + иконка / иконка + текст + иконка (возможно стоит не
  выделять и использовать `icon-content` вложенный в `button`)
- `list` для структуры списков (в текущей реализации это и списки карточек и
  список истории внутри карточки)

3. Выделим слой контентных блоков:

- `text` как самостоятельный блок и блок для миксов для оформления текста
  слоями `text_view` (цветовые решения) и `text type` (размерные решения в
  касксаде c `text_size` и разрешением)
- `icon` аналогично тексту
- `input` для `input_view` и `input_type`
- `meta` для мета информации. В текущей реализации больше семантический блок c
  заделом на будущее,
  внутри используем `icon-content` (так же хочу его в будущем иполльзовать в
  кнопках)
- `log` для вывода лога

_Q_ какие стили относятся к блокам, а какие к элементам и модификаторам?

Основной посыл блокам не давать внешнее позиционирование. Блоками рулить
структуру элементов внутри.

Элементами, в свою очередь, рулить собственное внешнее поведение.

Модификаторами рулить внешний вид, отступы, исключительные случаи, прокидывание
переменных.

Но главный вопрос на который пока нет ответа: лучше делить по-максимому или
стараться как можно меньше плодить сущностей. Пока, на практике, получется, что
если делать максимально большое количество всего, то в будущем проще.
Требования меняются, а у тебя уже есть "обертка" под все что угодно.

_Q_ где нужно использовать каскады и почему?

Для себя ввел простые ограничения:

- каскады не плохо.
- старайся по максимому уменьшить связность элементов (больше трех не собираться).
- никогда не связывай блоки

В итоге получилось, что я использую их в основном для:

- изменений размеров в зависимости от разрешения `.button_size_s .button__text`
  (хотя тут нужно подумать в сторону каскада с модификатором `text_size` блока
  текст, может лучше будет вкладывать, для системности)
  - `.button_size_m .button__text` вместо заведения лишних модификаторов на
    разрешения вроде `.buttin_text_s`
- раскидывания/собирания отступов внутри элементов при
  вертикальном/горизонтальном порядке `.input__group_vertical .input__label` и
  `.input__group_horizontal .input__label`
- заложенного автоматического взаимодействия связных элементов `.input_view_valid ~ .input__controls-append > button:after` для раскраски кнопки, иконки внутри
  кнопки и тому подобного.

## консистентность

_Q_ какие видите базовые и семантические константы?

Базовые:

- Цвета
- Размер текста
- Размер line-height
- Размер отступов
- Размер иконок

Семантические:

- Вид (action, control, error, warning, success, valid, invalid)
- Систему цветов построил так: есть базовые цвета. От них наследуются
  семантические цвета для вида. В моей реализации `color-ghost-XXX` и
  `color-control-XXX` могут иметь одинаковые значения, потому что у нас контролы
  серые. Но если надо поменять только контролы, то просто заводиться новый
  `цвет-base` и подставляется в семантические переменные контрола.

_Q_ какие видите закономерности в интерфейсе?

- Все вытекающие из ответов ниже.

## адаптивность

_Q_ где видите вариативность данных и как это обрабатываете?

1. Разный размер заголовков, текста, отступов на desktop/mobile. Решаю через
   media-query на семантические модификаторы.
2. Вертикальный и горизонтальный порядок внутренних элементов одинковых
   блоков на одном разрешении. Инвертированый порядок на другом. Решаю это через
   соглашение, что по-дефолту порядок всегда вертикальный. Для управления ввожу
   систему модификаторов `vertical` `m-vertical` `m-horizontal`. (К сожалению
   тут без каскада не смог обойтись, нужен мне для повышения специфичности
   селектора). Еще одно соглашение - повышаем специфичность на меньшем экране (в
   нашем случае desktop -> mobile). Но, видимо, ждут проблему если экранов
   станет больше. (по факту в коде еще каша, пока искал лаконичность в разных
   блоках пробовал разные подходы, что именно считаем за default)
3. Кнопки могут быть с иконкой / иконкой + текст / текст. Завел блок
   `icon-content`. Умеет все три случая, не портит окружение.
4. Строка может обрезаться на desktop и переноситься на mobile. Завел
   модификатор text_view_truncate для нужного разрешения.
5. Цвет иконок / текста / фокуса / бордеров может быть связан с находящимися
   друг с другом рядом элементами (input + button -> valid/invalid). Решил
   организацией цвета через сложные селекторы внутри нужных элементов. Сейчас в
   верстке используется простоя накидывание модификаторов на оба элемента, но
   работает и накидываение только на родительский для обоих (text_view /
   input_view ).

_Q_ какие видите особенности, связанные с размером экрана?

1. Тут я не знаю что ответить ) Все, вроде бы, выше описаное, связано и с
   размером экрана. Отступы изменяются. Размер шрифтов уменьшается. С логом
   билда на всю ширину - красиво, сразу понятно что надо скролить, был бы с
   обрамлении, было бы не так красиво.

_Q_ что еще повлияло на вашу вёрстку?

1. Внезапно, сама верстка. Предполагаю, что, как и многие,
   переделывал-перепридумывал несколько раз.
2. Подсмотренные решения на сайтах Яндекса и Gitlab-UI Storybook.
